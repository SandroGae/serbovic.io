<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>3D Shooter - Ultimate Sniper Edition</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 100;
    }
    /* Zentrales Fadenkreuz (Crosshair) */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      pointer-events: none;
      background: url('crosshair.png') no-repeat center center;
      background-size: contain;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="info">Klicke ins Fenster, um zu starten. Bewege dich mit WASD, Maus zum Umschauen, rechte Maustaste = Sniper-Zoom, linke Maustaste = Schiessen.</div>
  <div id="crosshair"></div>

  <!-- Three.js Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <!-- PointerLockControls für realistische FPS-Steuerung -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>

  <script>
    // Szene, Kamera und Renderer
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xa0a0a0);
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Licht: Ambient und Richtungslicht
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(50, 50, 50);
    scene.add(directionalLight);

    // Boden (großes Terrain)
    const groundGeo = new THREE.PlaneGeometry(1000, 1000);
    const groundMat = new THREE.MeshPhongMaterial({ color: 0x228B22 });
    const ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    scene.add(ground);

    // PointerLockControls für First-Person-Steuerung
    const controls = new THREE.PointerLockControls(camera, document.body);
    document.body.addEventListener('click', () => controls.lock(), false);
    scene.add(controls.getObject());

    // Bewegungsvariablen
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    const velocity = new THREE.Vector3();
    const direction = new THREE.Vector3();
    let prevTime = performance.now();

    document.addEventListener('keydown', event => {
      switch (event.code) {
        case 'KeyW': moveForward = true; break;
        case 'KeyS': moveBackward = true; break;
        case 'KeyA': moveLeft = true; break;
        case 'KeyD': moveRight = true; break;
      }
    });
    document.addEventListener('keyup', event => {
      switch (event.code) {
        case 'KeyW': moveForward = false; break;
        case 'KeyS': moveBackward = false; break;
        case 'KeyA': moveLeft = false; break;
        case 'KeyD': moveRight = false; break;
      }
    });

    // Ziele (Targets) zum Schiessen
    const targets = [];
    function createTarget(x, z) {
      const geometry = new THREE.BoxGeometry(2, 2, 2);
      const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
      const target = new THREE.Mesh(geometry, material);
      target.position.set(x, 1, z);
      scene.add(target);
      targets.push(target);
    }
    // Erzeuge 10 zufällige Ziele
    for (let i = 0; i < 10; i++) {
      createTarget((Math.random() - 0.5) * 200, (Math.random() - 0.5) * 200);
    }

    // Schiessen: Linke Maustaste
    document.addEventListener('mousedown', event => {
      if (event.button === 0) { // Linke Maustaste
        // Raycasting vom Kamerazentrum
        const raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(targets);
        if (intersects.length > 0) {
          const hit = intersects[0].object;
          scene.remove(hit);
          targets.splice(targets.indexOf(hit), 1);
          console.log("Treffer!");
        } else {
          console.log("Vorbei geschossen!");
        }
      }
    });

    // Sniper-Zoom: Rechte Maustaste
    let isSniperMode = false;
    document.addEventListener('mousedown', event => {
      if (event.button === 2) { // Rechte Maustaste
        isSniperMode = true;
        camera.fov = 20;
        camera.updateProjectionMatrix();
      }
    });
    document.addEventListener('mouseup', event => {
      if (event.button === 2) {
        isSniperMode = false;
        camera.fov = 75;
        camera.updateProjectionMatrix();
      }
    });
    // Kontextmenü unterdrücken
    window.addEventListener('contextmenu', event => event.preventDefault());

    // Animationsschleife
    function animate() {
      requestAnimationFrame(animate);
      const time = performance.now();
      const delta = (time - prevTime) / 1000;

      // Geschwindigkeitsdämpfung
      velocity.x -= velocity.x * 10.0 * delta;
      velocity.z -= velocity.z * 10.0 * delta;

      // Bewegungsrichtung bestimmen
      direction.z = Number(moveForward) - Number(moveBackward);
      direction.x = Number(moveRight) - Number(moveLeft);
      direction.normalize();

      // Beschleunigung
      if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
      if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

      controls.moveRight(-velocity.x * delta);
      controls.moveForward(-velocity.z * delta);

      prevTime = time;
      renderer.render(scene, camera);
    }
    animate();

    // Fenstergrößenanpassung
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
