<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>3D Shooter - Sniper Game</title>
  <style>
    body { margin: 0; overflow: hidden; background: #87CEEB; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 100;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 4px;
    }
    /* Zentrales Fadenkreuz */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      pointer-events: none;
      background: url('crosshair.png') no-repeat center center;
      background-size: contain;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="info">
    Steuerung:<br>
    W - vorwaerts, S - rueckwaerts,<br>
    A - links, D - rechts,<br>
    Maus bewegen = Zielen,<br>
    Linke Maustaste: Schiessen.
  </div>
  <div id="crosshair"></div>
  
  <!-- Three.js Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    let scene, camera, renderer;
    let player, playerSpeed = 10;
    let bullets = [];
    let explosions = [];
    let shootableObjects = [];
    let stones = [];
    let keys = {};
    let lastTime = performance.now();

    // Variablen für Kamerasteuerung (Zielen)
    let camYaw = 0;
    let camPitch = 0.2; // in Radianten (~11.5°)
    let mouseSensitivity = 0.002;

    init();
    animate();

    function init() {
      // Szene & Hintergrund (Himmel)
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x87CEEB, 100, 800);
      scene.background = new THREE.Color(0x87CEEB);

      // Kamera
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 2000);

      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);

      // Licht
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(100, 200, 100);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -300;
      directionalLight.shadow.camera.right = 300;
      directionalLight.shadow.camera.top = 300;
      directionalLight.shadow.camera.bottom = -300;
      scene.add(directionalLight);

      // Boden (Gras)
      const groundGeo = new THREE.PlaneGeometry(2000, 2000);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Wasser (See)
      const waterGeo = new THREE.PlaneGeometry(400, 400);
      const waterMat = new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.6 });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI / 2;
      water.position.set(300, 0.2, -300);
      water.receiveShadow = true;
      scene.add(water);

      // Wolken hinzufügen
      for (let i = 0; i < 5; i++) {
        let cloud = createCloud();
        cloud.position.set((Math.random()-0.5)*800, 150 + Math.random()*50, (Math.random()-0.5)*800);
        scene.add(cloud);
      }

      // Große, shootable Baeume
      for (let i = 0; i < 20; i++) {
        let tree = createTree();
        tree.position.set((Math.random()-0.5)*800, 0, (Math.random()-0.5)*800);
        scene.add(tree);
        shootableObjects.push(tree);
      }

      // Steine (nicht shootable, aber als Umgebungselemente)
      for (let i = 0; i < 30; i++) {
        let stone = createStone();
        stone.position.set((Math.random()-0.5)*800, 0.5, (Math.random()-0.5)*800);
        scene.add(stone);
        stones.push(stone);
      }

      // Shootable Targets (rote Boxen)
      for (let i = 0; i < 10; i++) {
        let target = createTarget();
        target.position.set((Math.random()-0.5)*400, 0.5, (Math.random()-0.5)*400);
        scene.add(target);
        shootableObjects.push(target);
      }

      // Spielerfigur: Gruppe aus Koerper und Kopf
      player = new THREE.Group();
      // Koerper
      const bodyGeo = new THREE.BoxGeometry(1, 2, 0.5);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1;
      body.castShadow = true;
      player.add(body);
      // Kopf
      const headGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 2.5;
      head.castShadow = true;
      player.add(head);
      player.position.set(0, 0, 0);
      scene.add(player);

      // Initiale Kameraposition und -ausrichtung
      camYaw = 0;
      camPitch = 0.2;
      updateCamera();

      // Event Listener
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('keyup', onKeyUp, false);
      window.addEventListener('mousedown', onMouseDown, false);
      window.addEventListener('mousemove', onMouseMove, false);
      window.addEventListener('resize', onWindowResize, false);
    }

    // Erzeugt eine Wolke als Gruppe aus mehreren Kugeln
    function createCloud() {
      let cloud = new THREE.Group();
      let cloudMat = new THREE.MeshStandardMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
      for (let i = 0; i < 5; i++) {
        let sphereGeo = new THREE.SphereGeometry(10, 16, 16);
        let sphere = new THREE.Mesh(sphereGeo, cloudMat);
        sphere.position.set((Math.random()-0.5)*20, (Math.random()-0.5)*10, (Math.random()-0.5)*20);
        cloud.add(sphere);
      }
      return cloud;
    }

    // Erzeugt einen grossen Baum (shootable)
    function createTree() {
      let tree = new THREE.Group();
      // Stamm
      const trunkGeo = new THREE.CylinderGeometry(0.5, 0.5, 8);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 4;
      trunk.castShadow = true;
      tree.add(trunk);
      // Laub
      const leavesGeo = new THREE.ConeGeometry(4, 8, 16);
      const leavesMat = new THREE.MeshStandardMaterial({ color: 0x006400 });
      const leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = 10;
      leaves.castShadow = true;
      tree.add(leaves);
      // Als shootable markieren
      tree.userData.shootable = true;
      tree.userData.hitRadius = 5;
      return tree;
    }

    // Erzeugt einen Stein
    function createStone() {
      const stoneGeo = new THREE.DodecahedronGeometry(1);
      const stoneMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
      const stone = new THREE.Mesh(stoneGeo, stoneMat);
      stone.castShadow = true;
      return stone;
    }

    // Erzeugt eine rote Box (shootable Target)
    function createTarget() {
      const targetGeo = new THREE.BoxGeometry(1, 1, 1);
      const targetMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const target = new THREE.Mesh(targetGeo, targetMat);
      target.castShadow = true;
      target.userData.shootable = true;
      target.userData.hitRadius = 1.5;
      return target;
    }

    function onKeyDown(event) {
      keys[event.code] = true;
    }
    function onKeyUp(event) {
      keys[event.code] = false;
    }
    function onMouseDown(event) {
      if(event.button === 0) { // Linke Maustaste: Schiessen
        shootBullet();
      }
    }
    function onMouseMove(event) {
      // Aktualisiere Kamerawinkel anhand der Mausbewegung
      camYaw -= event.movementX * mouseSensitivity;
      camPitch -= event.movementY * mouseSensitivity;
      // Begrenze den Pitch, um ein Umdrehen zu vermeiden
      camPitch = Math.max(-0.3, Math.min(1.0, camPitch));
      updateCamera();
    }
    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Aktualisiert die Kameraposition relativ zum Spieler
    function updateCamera() {
      // Spieler dreht sich entsprechend dem horizontalen Winkel
      player.rotation.y = camYaw;
      // Berechne den Kameraversatz (sphärische Koordinaten)
      let distance = 15;
      let offsetX = distance * Math.cos(camPitch) * Math.sin(camYaw);
      let offsetZ = distance * Math.cos(camPitch) * Math.cos(camYaw);
      let offsetY = distance * Math.sin(camPitch) + 2; // plus Kopfhoehe des Spielers
      camera.position.set(player.position.x + offsetX, player.position.y + offsetY, player.position.z + offsetZ);
      camera.lookAt(new THREE.Vector3(player.position.x, player.position.y + 2.5, player.position.z));
    }

    // Schiesst ein Geschoss (Zylinder), das sich in Richtung des Kamera-Ziels bewegt
    function shootBullet() {
      // Nutze die Kamerarichtung, damit auch die Vertikale beruecksichtigt wird
      let forward = new THREE.Vector3();
      camera.getWorldDirection(forward).normalize();
      const bulletGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
      const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);
      bullet.castShadow = true;
      // Richte den Zylinder so aus, dass seine Y-Achse (Standardachse) in die Schussrichtung zeigt
      bullet.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), forward);
      // Setze die Startposition: Kopfposition des Spielers plus ein kleiner Offset in Schussrichtung
      let startPos = new THREE.Vector3().copy(player.position).add(new THREE.Vector3(0, 2.5, 0));
      let forwardOffset = forward.clone().multiplyScalar(2);
      bullet.position.copy(startPos.add(forwardOffset));
      bullet.userData.velocity = forward.clone().multiplyScalar(50);
      bullets.push(bullet);
      scene.add(bullet);
    }

    // Erzeugt einen Explosionseffekt an einer bestimmten Position
    function createExplosion(position) {
      const explosionGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const explosionMat = new THREE.MeshStandardMaterial({ color: 0xffa500, transparent: true, opacity: 1 });
      const explosion = new THREE.Mesh(explosionGeo, explosionMat);
      explosion.position.copy(position);
      explosion.userData.startTime = performance.now();
      explosion.userData.duration = 1000; // 1 Sekunde
      explosions.push(explosion);
      scene.add(explosion);
    }

    function animate() {
      requestAnimationFrame(animate);
      let now = performance.now();
      let delta = (now - lastTime) / 1000;
      lastTime = now;

      // Spielerbewegung: W/S (vorwaerts/rueckwaerts) und A/D (Seitlich, relativ zur Kamera)
      let moveDirection = new THREE.Vector3();
      if (keys["KeyW"]) { moveDirection.z -= 1; }
      if (keys["KeyS"]) { moveDirection.z += 1; }
      if (keys["KeyA"]) { moveDirection.x -= 1; }
      if (keys["KeyD"]) { moveDirection.x += 1; }
      if (moveDirection.length() > 0) {
        moveDirection.normalize();
        // Drehung um camYaw, damit die Bewegung zur Kamerarichtung passt
        let angle = camYaw;
        let rotatedDir = new THREE.Vector3(
          moveDirection.x * Math.cos(angle) - moveDirection.z * Math.sin(angle),
          0,
          moveDirection.x * Math.sin(angle) + moveDirection.z * Math.cos(angle)
        );
        player.position.add(rotatedDir.multiplyScalar(playerSpeed * delta));
        updateCamera();
      }

      // Aktualisiere die Geschosse
      for (let i = bullets.length - 1; i >= 0; i--) {
        let bullet = bullets[i];
        bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
        // Kollision mit shootable Objekten (Baeume oder Boxen)
        for (let j = shootableObjects.length - 1; j >= 0; j--) {
          let obj = shootableObjects[j];
          let distance = bullet.position.distanceTo(obj.position);
          if (distance < obj.userData.hitRadius) {
            createExplosion(obj.position);
            scene.remove(obj);
            shootableObjects.splice(j, 1);
            scene.remove(bullet);
            bullets.splice(i, 1);
            break;
          }
        }
        // Entferne Geschoss, wenn es zu weit vom Spieler entfernt ist
        if (bullet.position.distanceTo(player.position) > 1000) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }

      // Aktualisiere Explosionen
      for (let i = explosions.length - 1; i >= 0; i--) {
        let explosion = explosions[i];
        let elapsed = now - explosion.userData.startTime;
        if (elapsed < explosion.userData.duration) {
          let scale = 1 + (elapsed / explosion.userData.duration) * 3;
          explosion.scale.set(scale, scale, scale);
          explosion.material.opacity = 1 - (elapsed / explosion.userData.duration);
        } else {
          scene.remove(explosion);
          explosions.splice(i, 1);
        }
      }

      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
