<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D-Chemiker</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #punkte, #leben {
      position: absolute;
      left: 10px;
      color: white;
      font-family: Arial, sans-serif;
    }
    #punkte { top: 10px; }
    #leben { top: 30px; }
    #message {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-family: Arial, sans-serif;
      font-size: 48px;
      text-align: center;
      background: rgba(0, 0, 0, 0.5);
      padding: 40px;
      border-radius: 10px;
      display: none;
      z-index: 10;
    }
    #gameOver {
      display: none;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      font-family: Arial, sans-serif;
      z-index: 10;
    }
    #restartBtn {
      font-size: 20px;
      padding: 10px 20px;
      margin-top: 20px;
    }
  </style>
</head>
<body>
  <div id="punkte">Punkte: 0</div>
  <div id="leben">Leben: 3</div>
  <div id="message">
    <h1>Herzlichen Glückwunsch, Joel, zum 28. Geburtstag!</h1>
    <p>Einladung zum All You Can Eat Fondue Shinuas!</p>
  </div>
  <div id="gameOver">
    <h1>Game Over!</h1>
    <button id="restartBtn">Neu starten</button>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
  <script>
    // === Konfigurierbare Parameter ===
    const SPEED_MULTIPLIER   = 1.0;
    const MAX_OBSTACLES      = 50;  // Maximale Anzahl der Hindernisse
    const MAX_COLLECTIBLES   = 20;  // Maximale Anzahl der Sammelobjekte
    const MAX_TREES          = 50;  // Maximale Anzahl der Baeume
    const MAX_STONES         = 50;  // Maximale Anzahl der Steine

    // === Basisgeschwindigkeiten ===
    const basePlayerSpeed      = 0.1;
    const baseObstacleSpeed    = 0.2;
    const baseCollectibleSpeed = 0.2;
    const baseEnvSpeed         = 0.15;  // Geschwindigkeit fuer Baeume und Steine
    const cloudSpeed           = 0.01;  // Wolkengeschwindigkeit

    let gameActive = true;

    // === Szene, Kamera und Renderer ===
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // === Boden: Zwei Bereiche ===
    // Au�erbereich (dunkles Gruen) - 100x100
    const outerGroundGeometry = new THREE.PlaneGeometry(100, 100);
    const outerGroundMaterial = new THREE.MeshPhongMaterial({ color: 0x006400 });
    const outerGround = new THREE.Mesh(outerGroundGeometry, outerGroundMaterial);
    outerGround.rotation.x = -Math.PI / 2;
    scene.add(outerGround);

    // Track: Bereich, in dem sich der Spieler bewegt (x zwischen -5 und 5) in Braun
    const trackGeometry = new THREE.PlaneGeometry(10, 100);
    const trackMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
    const track = new THREE.Mesh(trackGeometry, trackMaterial);
    track.rotation.x = -Math.PI / 2;
    track.position.y = 0.01;  // Leicht angehoben, um Z-Fighting zu vermeiden
    scene.add(track);

    // === Beleuchtung ===
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(0, 10, 10);
    scene.add(directionalLight);

    // === Hintergrund (Himmel) ===
    scene.background = new THREE.Color(0x87CEEB);

    // === Wolken, die sich langsam bewegen ===
    const clouds = [];
    function createCloud(x, y, z) {
      const cloud = new THREE.Group();
      const cloudGeo = new THREE.SphereGeometry(1, 16, 16);
      const cloudMat = new THREE.MeshPhongMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 });
      const part1 = new THREE.Mesh(cloudGeo, cloudMat);
      const part2 = new THREE.Mesh(cloudGeo, cloudMat);
      const part3 = new THREE.Mesh(cloudGeo, cloudMat);
      part1.position.set(0, 0, 0);
      part2.position.set(1, 0.2, 0);
      part3.position.set(-1, 0.2, 0);
      cloud.add(part1);
      cloud.add(part2);
      cloud.add(part3);
      cloud.scale.set(2, 2, 2);  // Groessere Wolke
      cloud.position.set(x, y, z);
      scene.add(cloud);
      clouds.push(cloud);
    }
    // Wolken im oberen Bereich platzieren:
    createCloud(-20, 25, -40);
    createCloud(0, 30, -50);
    createCloud(20, 27, -45);

    // === Spieler (Gruppe aus Kopf und Koerper) ===
    const player = new THREE.Group();
    const headGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const headMaterial = new THREE.MeshBasicMaterial({ color: 0xffd1a4 });
    const head = new THREE.Mesh(headGeometry, headMaterial);
    head.position.y = 1.5;
    player.add(head);
    const bodyGeometry = new THREE.BoxGeometry(1, 1, 0.5);
    const bodyMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff });
    const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
    body.position.y = 0.75;
    player.add(body);
    player.position.set(0, 0, 0);
    scene.add(player);

    // === Spielersteuerung ===
    let leftPressed = false;
    let rightPressed = false;
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') leftPressed = true;
      if (e.key === 'ArrowRight') rightPressed = true;
    });
    window.addEventListener('keyup', (e) => {
      if (e.key === 'ArrowLeft') leftPressed = false;
      if (e.key === 'ArrowRight') rightPressed = false;
    });

    // === Arrays f�r Objekte ===
    let obstacles = [];
    let collectibles = [];
    let trees = [];
    let stones = [];

    // === Hindernisse spawnen ===
    function spawnObstacle() {
      if (obstacles.length < MAX_OBSTACLES) {
        const geometry = new THREE.BoxGeometry(1, 1, 1);
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        const obstacle = new THREE.Mesh(geometry, material);
        const spawnZ = player.position.z - 50;
        // Im Track-Bereich (x zwischen -5 und 5)
        obstacle.position.set(Math.random() * 10 - 5, 0.5, spawnZ);
        scene.add(obstacle);
        obstacles.push(obstacle);
      }
    }

    // === Sammelobjekte spawnen ===
    function spawnCollectible() {
      if (collectibles.length < MAX_COLLECTIBLES) {
        const geometry = new THREE.SphereGeometry(0.5, 32, 32);
        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
        const collectible = new THREE.Mesh(geometry, material);
        const spawnZ = player.position.z - 50;
        collectible.position.set(Math.random() * 10 - 5, 0.5, spawnZ);
        scene.add(collectible);
        collectibles.push(collectible);
      }
    }

    // === Baeume spawnen ===
    function spawnTree() {
      if (trees.length < MAX_TREES) {
        const tree = new THREE.Group();
        // Baumstamm
        const trunkGeometry = new THREE.CylinderGeometry(0.2, 0.2, 2);
        const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
        const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
        trunk.position.y = 1.0;
        tree.add(trunk);
        // Laub
        const foliageGeometry = new THREE.ConeGeometry(1, 3, 8);
        const foliageMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22 });
        const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
        foliage.position.y = 2.5;
        tree.add(foliage);
        // Verteile �ber den gesamten gruenen Au�erbereich:
        // z.B. x-Werte zwischen 5 und 70 (bzw. -5 und -70)
        let side = Math.random() < 0.5 ? -1 : 1;
        let xMin = 5, xMax = 70;
        let xPos = side * (xMin + Math.random() * (xMax - xMin));
        let zPos = player.position.z - 50;
        tree.position.set(xPos, 0, zPos);
        scene.add(tree);
        trees.push(tree);
      }
    }

    // === Steine spawnen ===
    function spawnStone() {
      if (stones.length < MAX_STONES) {
        const stoneGeometry = new THREE.IcosahedronGeometry(1, 0);
        const stoneMaterial = new THREE.MeshPhongMaterial({ color: 0x808080 });
        const stone = new THREE.Mesh(stoneGeometry, stoneMaterial);
        let side = Math.random() < 0.5 ? -1 : 1;
        let xMin = 5, xMax = 70;
        let xPos = side * (xMin + Math.random() * (xMax - xMin));
        let zPos = player.position.z - 50;
        stone.position.set(xPos, 0.5, zPos);
        scene.add(stone);
        stones.push(stone);
      }
    }

    // === Punkte, Leben und Overlay-Elemente ===
    let punkte = 0;
    let leben = 3;
    const punkteElement = document.getElementById('punkte');
    const lebenElement = document.getElementById('leben');
    const messageElement = document.getElementById('message');
    const gameOverElement = document.getElementById('gameOver');
    const restartBtn = document.getElementById('restartBtn');

    // === Spiel zuruecksetzen ===
    function resetGame() {
      punkte = 0;
      leben = 3;
      punkteElement.textContent = `Punkte: ${punkte}`;
      lebenElement.textContent = `Leben: ${leben}`;
      player.position.set(0, 0, 0);
      camera.position.set(0, 5, 10);
      obstacles.forEach(obs => scene.remove(obs));
      collectibles.forEach(col => scene.remove(col));
      trees.forEach(tree => scene.remove(tree));
      stones.forEach(stone => scene.remove(stone));
      obstacles = [];
      collectibles = [];
      trees = [];
      stones = [];
      gameOverElement.style.display = 'none';
      messageElement.style.display = 'none';
      gameActive = true;
    }
    restartBtn.addEventListener('click', resetGame);

    // === Animations-Loop ===
    function animate() {
      requestAnimationFrame(animate);
      if (!gameActive) {
        renderer.render(scene, camera);
        return;
      }

      // Spieler bewegen
      player.position.z -= basePlayerSpeed * SPEED_MULTIPLIER;
      if (leftPressed && player.position.x > -5)
        player.position.x -= basePlayerSpeed * SPEED_MULTIPLIER;
      if (rightPressed && player.position.x < 5)
        player.position.x += basePlayerSpeed * SPEED_MULTIPLIER;

      // Kamera folgt dem Spieler
      camera.position.z = player.position.z + 10;
      camera.position.x = player.position.x;
      camera.lookAt(player.position);

      // Bodenbereiche aktualisieren
      outerGround.position.z = player.position.z;
      track.position.z = player.position.z;

      // Spawnen der Objekte:
      if (Math.random() < 0.05) spawnObstacle();
      if (Math.random() < 0.05) spawnCollectible();
      if (Math.random() < 0.03) spawnTree();    // Hier: 3% Chance pro Frame
      if (Math.random() < 0.03) spawnStone();   // Hier: 3% Chance pro Frame

      // Hindernisse bewegen und Kollision prüfen
      obstacles.forEach((obs, index) => {
        obs.position.z += baseObstacleSpeed * SPEED_MULTIPLIER;
        if (obs.position.z > player.position.z + 10) {
          scene.remove(obs);
          obstacles.splice(index, 1);
        }
        if (Math.abs(player.position.x - obs.position.x) < 1 &&
            Math.abs(player.position.z - obs.position.z) < 1) {
          leben -= 1;
          lebenElement.textContent = `Leben: ${leben}`;
          scene.remove(obs);
          obstacles.splice(index, 1);
          if (leben <= 0) {
            gameActive = false;
            gameOverElement.style.display = 'block';
          }
        }
      });

      // Sammelobjekte bewegen und Kollision prüfen
      collectibles.forEach((col, index) => {
        col.position.z += baseCollectibleSpeed * SPEED_MULTIPLIER;
        if (col.position.z > player.position.z + 10) {
          scene.remove(col);
          collectibles.splice(index, 1);
        }
        if (Math.abs(player.position.x - col.position.x) < 1 &&
            Math.abs(player.position.z - col.position.z) < 1) {
          punkte += 1;
          punkteElement.textContent = `Punkte: ${punkte}`;
          scene.remove(col);
          collectibles.splice(index, 1);
        }
      });

      // Baeume und Steine bewegen
      trees.forEach((tree, index) => {
        tree.position.z += baseEnvSpeed * SPEED_MULTIPLIER;
        if (tree.position.z > player.position.z + 10) {
          scene.remove(tree);
          trees.splice(index, 1);
        }
      });
      stones.forEach((stone, index) => {
        stone.position.z += baseEnvSpeed * SPEED_MULTIPLIER;
        if (stone.position.z > player.position.z + 10) {
          scene.remove(stone);
          stones.splice(index, 1);
        }
      });

      // Wolken bewegen (horizontal)
      clouds.forEach(cloud => {
        cloud.position.x += cloudSpeed;
        if (cloud.position.x > 50) {
          cloud.position.x = -50;
        }
      });

      // Ab einem Score von 30: Einladung anzeigen und Spiel pausieren
      if (punkte >= 30) {
        gameActive = false;
        messageElement.style.display = 'block';
      }

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>
