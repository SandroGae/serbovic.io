<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <title>3D Shooter - Ultimate Game World</title>
  <style>
    body { margin: 0; overflow: hidden; background: #87CEEB; }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: #fff;
      font-family: sans-serif;
      z-index: 100;
      background: rgba(0,0,0,0.5);
      padding: 5px 10px;
      border-radius: 4px;
    }
    /* Zentrales Fadenkreuz */
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 30px;
      pointer-events: none;
      background: url('crosshair.png') no-repeat center center;
      background-size: contain;
      z-index: 50;
    }
  </style>
</head>
<body>
  <div id="info">
    Steuerung:<br>
    W - vorwaerts, S - rueckwaerts,<br>
    A - links drehen, D - rechts drehen,<br>
    Linke Maustaste: Schiessen.
  </div>
  <div id="crosshair"></div>
  
  <!-- Three.js Bibliothek -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <script>
    let scene, camera, renderer;
    let player, playerSpeed = 5, rotationSpeed = Math.PI; // Einheiten pro Sekunde / Radiant pro Sekunde
    let bullets = [];
    let explosions = [];
    let shootableTargets = [];
    let keys = {};
    let lastTime = performance.now();
    
    init();
    animate();
    
    function init() {
      // Szene und Kamera
      scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x87CEEB, 100, 600);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      
      // Licht
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(50, 100, 50);
      directionalLight.castShadow = true;
      directionalLight.shadow.camera.left = -200;
      directionalLight.shadow.camera.right = 200;
      directionalLight.shadow.camera.top = 200;
      directionalLight.shadow.camera.bottom = -200;
      scene.add(directionalLight);
      
      // Boden (Gras)
      const groundGeo = new THREE.PlaneGeometry(1000, 1000);
      const groundMat = new THREE.MeshStandardMaterial({ color: 0x228B22 });
      const ground = new THREE.Mesh(groundGeo, groundMat);
      ground.rotation.x = -Math.PI/2;
      ground.receiveShadow = true;
      scene.add(ground);
      
      // Wasser (See)
      const waterGeo = new THREE.PlaneGeometry(200, 200);
      const waterMat = new THREE.MeshStandardMaterial({ color: 0x1E90FF, transparent: true, opacity: 0.6 });
      const water = new THREE.Mesh(waterGeo, waterMat);
      water.rotation.x = -Math.PI/2;
      water.position.set(150, 0.2, -100);
      water.receiveShadow = true;
      scene.add(water);
      
      // Umgebung: Baeume
      for(let i = 0; i < 30; i++){
        let tree = createTree();
        tree.position.set((Math.random()-0.5)*800, 0, (Math.random()-0.5)*800);
        scene.add(tree);
      }
      
      // Umgebung: Steine
      for(let i = 0; i < 20; i++){
        let stone = createStone();
        stone.position.set((Math.random()-0.5)*800, 0.35, (Math.random()-0.5)*800);
        scene.add(stone);
      }
      
      // Schiessbare Ziele: Rote Boxen
      for(let i = 0; i < 10; i++){
        let target = createTarget();
        target.position.set((Math.random()-0.5)*400, 0.5, (Math.random()-0.5)*400);
        scene.add(target);
        shootableTargets.push(target);
      }
      
      // Spielerfigur: Gruppe mit Koerper und Kopf
      player = new THREE.Group();
      
      // Koerper (Box)
      const bodyGeo = new THREE.BoxGeometry(1, 2, 0.5);
      const bodyMat = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.position.y = 1; // berührt den Boden
      body.castShadow = true;
      player.add(body);
      
      // Kopf (Sphere)
      const headGeo = new THREE.SphereGeometry(0.5, 32, 32);
      const headMat = new THREE.MeshStandardMaterial({ color: 0xffd700 });
      const head = new THREE.Mesh(headGeo, headMat);
      head.position.y = 2.5;
      head.castShadow = true;
      player.add(head);
      
      player.position.set(0, 0, 0);
      scene.add(player);
      
      // Kamera-Initialposition (Third-Person: hinter dem Spieler)
      updateCamera();
      
      // Event Listener
      window.addEventListener('keydown', onKeyDown, false);
      window.addEventListener('keyup', onKeyUp, false);
      window.addEventListener('mousedown', onMouseDown, false);
      window.addEventListener('resize', onWindowResize, false);
    }
    
    function onKeyDown(event) {
      keys[event.code] = true;
    }
    
    function onKeyUp(event) {
      keys[event.code] = false;
    }
    
    function onMouseDown(event) {
      if(event.button === 0) { // Linke Maustaste: Schiessen
        shootBullet();
      }
    }
    
    function onWindowResize() {
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    
    // Erzeugt einen Baum (Stamm + Laub)
    function createTree() {
      let tree = new THREE.Group();
      const trunkGeo = new THREE.CylinderGeometry(0.2, 0.2, 4);
      const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
      const trunk = new THREE.Mesh(trunkGeo, trunkMat);
      trunk.position.y = 2;
      trunk.castShadow = true;
      tree.add(trunk);
      
      const leavesGeo = new THREE.ConeGeometry(1.5, 4, 8);
      const leavesMat = new THREE.MeshStandardMaterial({ color: 0x006400 });
      const leaves = new THREE.Mesh(leavesGeo, leavesMat);
      leaves.position.y = 5;
      leaves.castShadow = true;
      tree.add(leaves);
      
      return tree;
    }
    
    // Erzeugt einen Stein
    function createStone() {
      const stoneGeo = new THREE.DodecahedronGeometry(0.5);
      const stoneMat = new THREE.MeshStandardMaterial({ color: 0x808080 });
      const stone = new THREE.Mesh(stoneGeo, stoneMat);
      stone.castShadow = true;
      return stone;
    }
    
    // Erzeugt ein schiessbares Ziel (rote Box)
    function createTarget() {
      const targetGeo = new THREE.BoxGeometry(1, 1, 1);
      const targetMat = new THREE.MeshStandardMaterial({ color: 0xff0000 });
      const target = new THREE.Mesh(targetGeo, targetMat);
      target.castShadow = true;
      target.userData.shootable = true;
      return target;
    }
    
    // Schiesst eine Kugel (zylinderfoermig)
    function shootBullet() {
      const bulletGeo = new THREE.CylinderGeometry(0.1, 0.1, 1, 8);
      const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
      const bullet = new THREE.Mesh(bulletGeo, bulletMat);
      bullet.castShadow = true;
      // Richte den Zylinder horizontal aus
      bullet.rotation.x = Math.PI / 2;
      
      // Bestimme die Vorwaertsrichtung des Spielers
      let forward = new THREE.Vector3(0, 0, -1);
      forward.applyQuaternion(player.quaternion).normalize();
      
      // Starte etwas vor dem Spieler, in Kopfhöhe
      bullet.position.copy(player.position)
            .add(new THREE.Vector3(0, 2, 0))
            .add(forward.clone().multiplyScalar(1.5));
      
      // Setze die Geschwindigkeit der Kugel (Einheiten pro Sekunde)
      bullet.userData.velocity = forward.multiplyScalar(20);
      bullets.push(bullet);
      scene.add(bullet);
    }
    
    // Erzeugt einen Explosionseffekt an einer bestimmten Position
    function createExplosion(position) {
      const explosionGeo = new THREE.SphereGeometry(0.5, 16, 16);
      const explosionMat = new THREE.MeshStandardMaterial({ color: 0xffa500, transparent: true, opacity: 1 });
      const explosion = new THREE.Mesh(explosionGeo, explosionMat);
      explosion.position.copy(position);
      explosion.userData.startTime = performance.now();
      explosion.userData.duration = 1000; // 1 Sekunde
      explosions.push(explosion);
      scene.add(explosion);
    }
    
    // Aktualisiert die Kamera-Position relativ zum Spieler (Third-Person)
    function updateCamera() {
      // Kamera soll hinter dem Spieler sein
      let offset = new THREE.Vector3(0, 5, 10); // etwas hoch und hinter dem Spieler
      offset.applyQuaternion(player.quaternion);
      camera.position.copy(player.position).add(offset);
      // Blick leicht nach oben, damit der Kopf des Spielers sichtbar ist
      let lookAtPos = player.position.clone().add(new THREE.Vector3(0, 2, 0));
      camera.lookAt(lookAtPos);
    }
    
    // Animationsschleife
    function animate() {
      requestAnimationFrame(animate);
      let now = performance.now();
      let delta = (now - lastTime) / 1000;
      lastTime = now;
      
      // Spielerbewegung (W/S fuer Vorwaerts/Rueckwaerts)
      let moveVector = new THREE.Vector3();
      if(keys["KeyW"]) { moveVector.z -= 1; }
      if(keys["KeyS"]) { moveVector.z += 1; }
      if(moveVector.length() > 0) {
        moveVector.normalize();
        moveVector.applyQuaternion(player.quaternion);
        player.position.add(moveVector.multiplyScalar(playerSpeed * delta));
      }
      
      // Spielerrotation (A/D)
      if(keys["KeyA"]) { player.rotation.y += rotationSpeed * delta; }
      if(keys["KeyD"]) { player.rotation.y -= rotationSpeed * delta; }
      
      // Kamera folgt dem Spieler
      updateCamera();
      
      // Aktualisiere Kugeln
      for(let i = bullets.length - 1; i >= 0; i--){
        let bullet = bullets[i];
        bullet.position.add(bullet.userData.velocity.clone().multiplyScalar(delta));
        
        // Kollisionsabfrage mit schiessbaren Zielen
        for(let j = shootableTargets.length - 1; j >= 0; j--){
          let target = shootableTargets[j];
          if(bullet.position.distanceTo(target.position) < 1) {
            createExplosion(target.position);
            scene.remove(target);
            shootableTargets.splice(j, 1);
            scene.remove(bullet);
            bullets.splice(i, 1);
            break;
          }
        }
        
        // Entferne Kugel, wenn sie zu weit fliegt
        if(bullet.position.distanceTo(player.position) > 500) {
          scene.remove(bullet);
          bullets.splice(i, 1);
        }
      }
      
      // Aktualisiere Explosionseffekte
      for(let i = explosions.length - 1; i >= 0; i--){
        let explosion = explosions[i];
        let elapsed = now - explosion.userData.startTime;
        if(elapsed < explosion.userData.duration) {
          let scale = 1 + (elapsed / explosion.userData.duration) * 3;
          explosion.scale.set(scale, scale, scale);
          explosion.material.opacity = 1 - (elapsed / explosion.userData.duration);
        } else {
          scene.remove(explosion);
          explosions.splice(i, 1);
        }
      }
      
      renderer.render(scene, camera);
    }
  </script>
</body>
</html>
